#basics

import React from "react";
import ReactDOM from "react-dom/client";

const heading = React.createElement(
  "h1",
  { id: "heading", xyz: "abc" },
  "Hellow World! from React"
);
const root = ReactDOM.createRoot(document.getElementById("root"));
console.log("roort->", root);
// root.render(heading);

{
  /* <div id="parent">
  <div id="child">
    <h1>This is a h1 tag!</h1>
  </div>
</div> */
}

// const parent = React.createElement(
//   "div",
//   { id: "parent" },
//   React.createElement(
//     "div",
//     { id: "child" },
//     React.createElement("h1", {}, "This is a h1 tag!")
//   )
// );
const parent = (
  <div id="parent">
    <h1>This is a h1 tag by jsx!</h1>
  </div>
);

// root.render(parent);

console.log("parent-->", parent); // This is nothing but a object
// so, React.createElement doesn't create the element, it creates a object which contains all the properties of the element,
// ReactDom then convertes the object to actual element and place it into the DOM while rendering it.

// If we want to create a sibling element, we need to put those childs inside an array

{
  /* <div id="parent">
    <div id="child">
      <h1>This is a h1 tag!</h1>
      <h2>This is a h2 tag!</h2>
    </div>
  </div> */
}

const parent2 = React.createElement(
  "div",
  { id: "parent" },
  React.createElement("div", { id: "child" }, [
    React.createElement("h1", {}, "This is Namaste React ðŸš€"),
    React.createElement("h2", {}, "This is a h2 tag!"),
  ])
);

// root.render(parent);

// if There is a tag already present in our html code, in our #root,
// while rendering, that tag/those tags will be replaced ( not appended, html will first print it on the screen then it will be replaced ) by whatever we
// will be passing inside our render method

const Title = () => <h1>Namste React using JSX ðŸš€</h1>;
const NewTitle = () => <h2>Namster React New Title using JSX ðŸš€</h2>;

// React functional component
// This is component composition ( component inside component)
const HeadingComponent = () => {
  return (
    <div id="container">
      <Title />
      <Title></Title>
      {/* as react component at the end of the day is a normal function and we can execute any js code inside our component we can call ther functional componet as normal function*/}
      {NewTitle()}
      <h1>Namaste React functional component!</h1>
    </div>
  );
};

root.render(<HeadingComponent />);



#Episode 3

JSX -> React.createElement (which is an object) -> HTML Element 
This whole transpilation is done by babel which is govern by Parcel
babel is just another package which parcel uses to transpile the code before reaching to the js engine.

two ways to create components in react.
1. Functional component
2. Class component


React Functional component is a normal javascript function which returns a jsx.

## differnce between react component and React element?


In React component any js can be executed. That's why there might be threat fo cross site scripting attack
through api. but react takes care of it. and it actually doesn't executer every data blindly, it actually filters the data.


#Episode 4

/*
 * Header
    - Logo
    - Nav Items
 * Body
    - Search
    - RestaurantContainer
      - RestaurantCard
        - Image
        - Name of Res, Star Rating, cuisine, delervery title
 * Footer
    - Copyright
    - Links
    - Address
    - Contact
 */

what is prop? 
prop -> property
we can pass data as prop to component.
prop is an object
props can be destructured on the fly {}


** config driven UI 

whenever we use map in react we need to give a unique key property to each child element.
and we should not use index as key.



#Episode 5


From a module only one dafault export is allowed. 
So when we have to export multiple things from one component we use Named export

export const Variable_name = "..."

Default export/import 

export default component;
import Component from "path";

Named export/import

export const Component;
import {Component} from "path";

## React Hooks
(Normal utility Javascript functions developed by facebook developers)

- useState() ~ Super powerfull react state Variable
it returns an array. then we can do the array destrucruring on the fly.
- useEffect()

Whenever a state variable updates/changes, react rerenders the component.
The logic of updating the UI is called rerendering.
React keeps sync between UI layer and data layer that's why its very fast
ast DOM operations it automatically rerenders the UI as soon as the data/state
changes.

** React uses Reconciliation algorithm which is known as (React Fiber). => React-16
React Fiber is a new way to find the div and updating the DOM.
virtual dom is a representation of actual DOM which is nothing but an object.

## Diff algorithm
React uses two virtual DOM to update the UI
Previous Virtual DOM and Updated Virtual DOM
using this algorithm react keeps track of the differences between thease two virtual DOMs
and then it will update the actual DOM on every render cycle.

React is fast because it does efficient DOM manipulation using virtual DOM
https://github.com/acdlite/react-fiber-architecture



# Episode 6:

1. Monolith architecture
All the services/usecases (UI, backend, sms service, Authentication, DB) written in
a single project


2. Microservice architecture
For all the services there are different different projects

How do the services communicate with each other?
- Through api calls/different different port numbers

- Seperation of concerns -> Follow a single responsibility principle


- useEffect()
This is nothing but a simple js function which takes two arguments
first is and callback function and second is dependency array

the useEffect function will call the callback function
after the initial render of the component is done.

we will use it when we want something to happen after the react render cycle is 
finished.

fetch() is not part of js. it is a part of browser's js engine.
It is used to make api calls.






